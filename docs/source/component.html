<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='global-property-'>/**
</span> * @license MIT http://troopjs.mit-license.org/
 */
define([
  &quot;troopjs-core/component/emitter&quot;,
  &quot;./config&quot;,
  &quot;./executor&quot;,
  &quot;./error&quot;,
  &quot;troopjs-compose/decorator/before&quot;,
  &quot;jquery&quot;,
  &quot;when/when&quot;,
  &quot;mu-selector-set/main&quot;,
  &quot;mu-jquery-destroy/main&quot;
], function (Component, config, executor, DOMError, before, $, when, SelectorSet) {
  &quot;use strict&quot;;

<span id='dom-component'>  /**
</span>   * Component that manages all DOM manipulation and integration.
   * @class dom.component
   * @extend core.component.emitter
   * @mixin dom.config
   * @alias feature.component
   */

  var UNDEFINED;
  var NULL = null;
  var OBJECT_TOSTRING = Object.prototype.toString;
  var TOSTRING_FUNCTION = &quot;[object Function]&quot;;
  var $ELEMENT = &quot;$element&quot;;
  var LENGTH = &quot;length&quot;;
  var PROXY = &quot;proxy&quot;;
  var DOM = &quot;dom&quot;;
  var ARGS = &quot;args&quot;;
  var NAME = &quot;name&quot;;
  var VALUE = &quot;value&quot;;
  var TYPE = config.emitter.type;
  var EXECUTOR = config.emitter.executor;
  var SCOPE = config.emitter.scope;
  var DATA = config.emitter.data;
  var DIRECT = &quot;direct&quot;;
  var DELEGATED = &quot;delegated&quot;;
  var SIG_RENDER = config.signal.render;
  var RE = new RegExp(&quot;^&quot; + DOM + &quot;/(.+)&quot;);

  function $render ($element, method, args) {
    var me = this;
    var length = args[LENGTH];

    return when(args[0], function (content) {
      var _length;
      var _args;

      // If `content` is a string we can return fast
      if (OBJECT_TOSTRING.call(content) !== TOSTRING_FUNCTION) {
        return content;
      }

      // Initialize `_length` and `_args`
      _length = length;
      _args = new Array(_length - 1);

      // Copy `args` to `_args`
      while (_length-- &gt; 1) {
        _args[_length - 1] = args[_length];
      }

      // Return result of applying `content` on `$element` with `_args`
      return content.apply($element, _args);
    })
    .then(function (content) {
      // Let `args[0]` be `$(content)`
      // Let `$content` be `args[0]`
      var $content = args[0] = $(content);
      // Initialize `_length` and `_args`
      var _length = length;
      var _args = new Array(_length + 1);

      // Let `_args[0]` be `SIG_RENDER`
      _args[0] = SIG_RENDER;

      // Copy `args` to `_args`
      while (_length-- &gt; 0) {
        _args[_length + 1] = args[_length];
      }

      // Determine direction of manipulation\
      switch (method) {
        case &quot;appendTo&quot;:
        case &quot;prependTo&quot;:
          $content[method]($element);
          break;

        default:
          $element[method]($content);
      }

      // Emit `_args`
      // Yield `args`
      return me.emit
        .apply(me, _args)
        .yield(args);
    });
  }

<span id='dom-component-event-sig-render'>  /**
</span>   * Render signal
   * @event sig/render
   * @localdoc Triggered after {@link #before}, {@link #after}, {@link #html}, {@link #text}, {@link #append}, {@link #appendTo}, {@link #prepend} and {@link #prependTo}
   * @since 3.0
   * @param {jQuery} $target Element rendered into
   * @param {...*} [args] Render arguments
   */

<span id='dom-component-handler-sig-render'>  /**
</span>   * Handles component render
   * @handler sig/render
   * @template
   * @inheritdoc #event-sig/render
   * @return {Promise}
   */

<span id='dom-component-event-dom-destroy'>  /**
</span>   * Destroy DOM event
   * @localdoc Triggered when {@link #$element} of this widget is removed from the DOM tree.
   * @event dom/destroy
   * @param {jQuery} $event jQuery event object
   * @param {...*} [args] Event arguments
   * @preventable
   */

<span id='dom-component-handler-dom-destroy'>  /**
</span>   * Handles widget destruction from a DOM perspective
   * @handler dom/destroy
   * @template
   * @inheritdoc #event-dom/destroy
   * @localdoc Triggered when this widget is removed from the DOM
   */

<span id='dom-component-method-html'>  /**
</span>   * Renders content and replaces {@link #$element} html contents
   * @method html
   * @param {Function|String|Promise} [contentOrPromise] Contents to render or a Promise for contents
   * @param {...*} [args] Template arguments
   * @fires sig/render
   * @return {String|Promise} The returned content string or promise of rendering.
   */

<span id='dom-component-method-text'>  /**
</span>   * Renders content and replaces {@link #$element} text contents
   * @method text
   * @inheritdoc #html
   * @fires sig/render
   */

<span id='dom-component-method-before'>  /**
</span>   * Renders content and inserts it before {@link #$element}
   * @method before
   * @inheritdoc #html
   * @fires sig/render
   * @return {Promise} The promise of rendering.
   */

<span id='dom-component-method-after'>  /**
</span>   * Renders content and inserts it after {@link #$element}
   * @method after
   * @inheritdoc #html
   * @fires sig/render
   */

<span id='dom-component-method-append'>  /**
</span>   * Renders content and appends it to {@link #$element}
   * @method append
   * @inheritdoc #html
   * @fires sig/render
   */

<span id='dom-component-method-appendTo'>  /**
</span>   * Renders content and appends it to the provided $element
   * @method appendTo
   * @param {jQuery} $element Target element
   * @param {Function|String|Promise} [contentOrPromise] Contents to render or a Promise for contents
   * @param {...*} [args] Template arguments
   * @fires sig/render
   * @return {Promise} The promise of rendering.
   */

<span id='dom-component-method-prepend'>  /**
</span>   * Renders content and prepends it to {@link #$element}
   * @method prepend
   * @inheritdoc #html
   * @fires sig/render
   */


<span id='dom-component-method-prependTo'>  /**
</span>   * Renders content and prepends it to the provided $element
   * @method prependTo
   * @inheritdoc #appendTo
   * @fires sig/render
   */
<span id='dom-component-method-constructor'>  /**
</span>   * Creates a new component that attaches to a specified (jQuery) DOM element.
   * @method constructor
   * @param {jQuery|HTMLElement} $element The element that this component should be attached to
   * @param {String} [displayName] A friendly name for this component
   * @throws {dom.error} If no $element is provided
   */
  return Component.extend(
    function ($element, displayName) {
      var me = this;
      var length = arguments[LENGTH];
      var args = new Array(length);
      var $get;

      // No $element
      if ($element === UNDEFINED || $element === NULL) {
        throw new DOMError(&quot;No '$element' provided&quot;);
      }

      // Let `args` be `ARRAY_SLICE.call(arguments)` without deop
      while (length-- &gt; 0) {
        args[length] = arguments[length];
      }

      // Is _not_ a jQuery element
      if (!$element.jquery) {
        // Let `$element` be `$($element)`
        // Let `args[0]` be `$element`
        args[0] = $element = $($element);
      }
      // From a different jQuery instance
      else if (($get = $element.get) !== $.fn.get) {
        // Let `$element` be `$($get.call($element, 0))`
        // Let `args[0]` be `$element`
        args[0] = $element = $($get.call($element, 0));
      }

<span id='dom-component-property-S-element'>      /**
</span>       * jQuery element this widget is attached to
       * @property {jQuery} $element
       * @readonly
       */
      me[$ELEMENT] = $element;

      // Update `me.displayName` if `displayName` was supplied
      if (displayName !== UNDEFINED) {
        me.displayName = displayName;
      }

      // Return potentially modified `args`
      return args;
    },

    {
      &quot;displayName&quot;: &quot;dom/component&quot;,

<span id='dom-component-handler-sig-initialize'>      /**
</span>       * @handler
       * @localdoc Registers event handlers that are declared as DOM specials.
       * @inheritdoc
       */
      &quot;sig/initialize&quot;: function () {
        var me = this;
        var specials = me.constructor.specials;

        if (specials.hasOwnProperty(DOM)) {
          specials[DOM].forEach(function (special) {
            me.on(special[NAME], special[VALUE], special[ARGS][0]);
          });
        }
      },

<span id='dom-component-handler-sig-setup'>      /**
</span>       * @handler
       * @localdoc Registers DOM event proxies on {@link #$element}.
       * @inheritdoc
       */
      &quot;sig/setup&quot;: function (handlers, type) {
        var me = this;
        var matches;

        // Check that this is a DOM handler
        if ((matches = RE.exec(type)) !== NULL) {
          // Create delegated and direct event stores
          handlers[DIRECT] = [];
          handlers[DELEGATED] = new SelectorSet();

          // `$element.on` `handlers[PROXY]`
          me[$ELEMENT].on(matches[1], NULL, me, handlers[PROXY] = function () {
            var length = arguments[LENGTH];
            var args = new Array(length + 1);
            var _args = args[0] = {};
            _args[TYPE] = type;
            _args[EXECUTOR] = executor;
            _args[SCOPE] = me;

            while (length &gt; 0) {
              args[length] = arguments[--length];
            }

            // Return result of emit
            return me.emit.apply(me, args);
          });
        }
      },

<span id='dom-component-handler-sig-added'>      /**
</span>       * @handler
       * @localdoc Adds handler to `handlers[DELEGATED]` or `handlers[DIRECT]` depending on `handler[DATA]`.
       * @inheritdoc #event-sig/added
       */
      &quot;sig/added&quot;: function (handlers, handler) {
        var data;

        // Check that this is a DOM handler
        if (RE.test(handler[TYPE])) {
          data = handler[DATA];

          if (data !== UNDEFINED) {
            handlers[DELEGATED].add(data, handler);
          }
          else {
            handlers[DIRECT].push(handler);
          }
        }
      },

<span id='dom-component-handler-sig-teardown'>      /**
</span>       * @handler
       * @localdoc Removes the DOM event proxies that are registered on {@link #$element}.
       * @inheritdoc
       */
      &quot;sig/teardown&quot;: function (handlers, type) {
        var me = this;
        var matches;

        // Check that this is a DOM handler
        if ((matches = RE.exec(type)) !== NULL) {
          // $element.off handlers[PROXY]
          me[$ELEMENT].off(matches[1], NULL, handlers[PROXY]);
        }
      },

<span id='dom-component-handler-sig-removed'>      /**
</span>       * @handler
       * @localdoc Removes handle from `handlers[DELEGATED]` or `handlers[DIRECT]` depending on `handler[DATA]`.
       * @inheritdoc #event-sig/removed
       */
      &quot;sig/removed&quot;: function (handlers, handler) {
        var data;

        // Check that this is a DOM handler
        if (RE.test(handler[TYPE])) {
          data = handler[DATA];

          if (data !== UNDEFINED) {
            handlers[DELEGATED].remove(data, handler);
          }
          else {
            handlers[DIRECT] = handlers[DIRECT].filter(function (_handler) {
              return _handler !== handler;
            });
          }
        }
      }
    },

    // Create spec for render methods targeting `me[$ELEMENT]` that can be executed without args
    [ &quot;html&quot;, &quot;text&quot; ].reduce(function (spec, method) {
      // Create `spec[method]`
      spec[method] = function () {
        var me = this;
        var $element = me[$ELEMENT];
        var length = arguments[LENGTH];
        var args;
        var result;

        // If there were no arguments ...
        if (length === 0) {
          // ... call `$element[method]` without arguments ...
          result = $element[method]();
        }
        // ... otherwise ...
        else {
          // Create `args`
          args = new Array(length);

          // Let `args` be `ARRAY_SLICE.call(arguments)` without deop
          while (length-- &gt; 0) {
            args[length] = arguments[length];
          }

          result = $render.call(me, $element, method, args);
        }

        return result;
      };

      // Return spec for next iteration
      return spec;
    }, {}),

    // Create spec for render methods targeting `me[$ELEMENT]`
    [ &quot;before&quot;, &quot;after&quot;, &quot;append&quot;, &quot;prepend&quot; ].reduce(function (spec, method) {
      // Create `spec[method]`
      spec[method] = function () {
        var me = this;
        var length = arguments[LENGTH];
        var args = new Array(length);

        // Let `args` be `ARRAY_SLICE.call(arguments)` without deop
        while (length-- &gt; 0) {
          args[length] = arguments[length];
        }

        return $render.call(me, me[$ELEMENT], method, args);
      };

      // Return spec for next iteration
      return spec;
    }, {}),

    // Create spec for render methods targeting provided `$element`
    [ &quot;appendTo&quot;, &quot;prependTo&quot; ].reduce(function (spec, method) {
      // Create `spec[method]`
      spec[method] = function ($element) {
        var length = arguments[LENGTH];
        var args = new Array(length - 1);

        // Let `args` be `ARRAY_SLICE.call(arguments, 1)` without deop
        while (length-- &gt; 1) {
          args[length - 1] = arguments[length];
        }

        return $render.call(this, $element, method, args);
      };

      // Return spec for next iteration
      return spec;
    }, {})
  );
});
</pre>
</body>
</html>
