<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='global-property-'>/**
</span> * @license MIT http://troopjs.mit-license.org/
 */
define([ &quot;./console&quot; ], function (logger) {
	&quot;use strict&quot;;

<span id='log-logger'>	/**
</span>	 * The console interface describes the API of the client's debugging console
	 * (e.g. the [Web Console](https://developer.mozilla.org/en-US/docs/Tools/Web_Console) in Firefox).
	 * The specifics of how it works vary from client to client, but there is a _de facto_ set of features that are
	 * typically provided.
	 *
	 * ## Outputting text to the console
	 *
	 * The most frequently-used feature of the console is logging of text and other data.
	 * There are four categories of output you can generate, using the {@link #log}, {@link #info}, {@link #warn},
	 * and {@link #error} methods. Each of these results in output that's styled differently in the log,
	 * and you can use the filtering controls provided by your client to only view the kinds of output that interest you.
	 *
	 * There are two ways to use each of the output methods; you can simply pass in a list of objects whose
	 * string representations get concatenated into one string then output to the console, or you can pass in a string
	 * containing zero or more substitution strings followed by a list of the objects with which to replace them.
	 *
	 * ### Writing a single object
	 *
	 * The simplest way to use the logging methods is to output a single object:
	 *
	 *     var someObject = { str: &quot;Some text&quot;, id: 5 };
	 *     logger.log(someObject);
	 *
	 * The output looks something like this:
	 *
	 *     [09:27:13.475] ({str:&quot;Some text&quot;, id:5})
	 *
	 * ### Writing multiple objects
	 *
	 * You can also output multiple objects by simply listing them when calling the logging method, like this:
	 *
	 *     var car = &quot;Dodge Charger&quot;;
	 *     var someObject = {str:&quot;Some text&quot;, id:5};
	 *     console.info(&quot;My first car was a&quot;, car, &quot;. The object is: &quot;, someObject);
	 *
	 * This output will look like this:
	 *
	 *     [09:28:22.711] My first car was a Dodge Charger . The object is:  ({str:&quot;Some text&quot;, id:5})
	 *
	 * ### Using string substitutions
	 *
	 * When passing a string to one of the console methods that accepts a string, you may use these substitution strings:
	 *
	 * - `%o`         : Outputs a hyperlink to a JavaScript object. Clicking the link opens an inspector.
	 * - `%d` or `%i` : Outputs an integer. Formatting is not yet supported.
	 * - `%s`         : Outputs a string.
	 * - `%f`         : Outputs a floating-point value. Formatting is not yet supported.
	 *
	 * Each of these pulls the next argument after the format string off the parameter list. For example:
	 *
	 *     for (var i=0; i&lt;5; i++) {
	 *       console.log(&quot;Hello, %s. You've called me %d times.&quot;, &quot;Bob&quot;, i+1);
	 *     }
	 *
	 * The output looks like this:
	 *
	 *     [13:14:13.481] Hello, Bob. You've called me 1 times.
	 *     [13:14:13.483] Hello, Bob. You've called me 2 times.
	 *     [13:14:13.485] Hello, Bob. You've called me 3 times.
	 *     [13:14:13.487] Hello, Bob. You've called me 4 times.
	 *     [13:14:13.488] Hello, Bob. You've called me 5 times.
	 *
	 * ## Timers
	 *
	 * In order to calculate the duration of a specific operation, you can use timers.
	 * To start a timer, call the {@link #time} method, giving it a name as only parameter.
	 * To stop the timer, and to get the elapsed time in miliseconds, just call the {@link #timeEnd} method,
	 * again passing the timer's name as the parameter.
	 * Up to 10,000 timers can run simultaneously on a given page.
	 *
	 * For example, given this code:
	 *
	 *     console.time(&quot;answer time&quot;);
	 *     alert(&quot;Click to continue&quot;);
	 *     console.timeEnd(&quot;answer time&quot;);
	 *
	 * will log the time needed by the user to discard the alert box:
	 *
	 *     13:50:42.246: answer time: timer started
	 *     13:50:43.243: answer time: 998ms
	 *
	 * Notice that the timer's name is displayed both when the timer is started and when it's stopped.
	 *
	 * ## Stack traces
	 *
	 * The console also supports outputting a stack trace; this will show you the call path taken to reach the point at
	 * which you call {@link #trace}. Given code like this:
	 *
	 *     foo();
	 *       function foo() {
	 *         function bar() {
	 *           console.trace();
	 *         }
	 *       bar();
	 *     }
	 *
	 * The output in the console looks something like this:
	 *
	 *     console.trace():   main.js:46
	 *       bar()           main.js:46
	 *       foo()           main.js:48
	 *       &lt;anonymous&gt;     main.js:42
	 *
	 * &lt;div class=&quot;notice&quot;&gt;
	 * Documentation for this class comes from &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/console&quot;&gt;MDN&lt;/a&gt;
	 * and is available under &lt;a href=&quot;http://creativecommons.org/licenses/by-sa/2.0/&quot;&gt;Creative Commons: Attribution-Sharealike license&lt;/a&gt;.
	 * &lt;/div&gt;
	 *
	 * @localdoc
	 * ## Changing framework logger
	 * This is a _virtual_ class that under normal circumstances is an alias for the {@link log.console} sink.
	 *
	 * If you want to change logger sink in your application you should use the [requirejs map config](http://requirejs.org/docs/api.html#config-map)
	 * to map this class to any module that implements the {@link log.logger} API.
	 *
	 * An example configuration that would change the logger to {@link log.null} would look like this:
	 *
	 *     requirejs.config({
	 *       &quot;map&quot;: {
	 *         &quot;*&quot;: {
	 *           &quot;troopjs-log/logger&quot;: &quot;troopjs-log/null&quot;
	 *         }
	 *       }
	 *     });
	 *
	 * @class log.logger
	 * @singleton
	 * @interface
	 * @alias feature.logger
	 */

<span id='log-logger-method-assert'>	/**
</span>	 * Writes a message and stack trace to the log if first argument is false
	 * @method assert
	 * @param {Boolean} expression Conditional expression
	 * @param {Object|String} payload Initial payload
	 * @param {Object...} [obj] Supplementary payloads
	 *
	 * - If `payload` is of type `Object` the string representations of each of these objects are appended together in the order listed and output.
	 * - If `payload` is of type `String` these are JavaScript objects with which to replace substitution strings within payload.
	 */

<span id='log-logger-method-debug'>	/**
</span>	 * Writes a message to the log with level `debug`
	 * @method debug
	 * @inheritdoc #log
	 * @deprecated An alias for {@link #log}. This was added to improve compatibility with existing sites already using `debug()`. However, you should use {@link #log} instead.
	 */

<span id='log-logger-method-dir'>	/**
</span>	 * Displays an interactive list of the properties of the specified JavaScript object. The output is presented as a hierarchical listing that let you see the contents of child objects.
	 * @method dir
	 * @param {Object} object A JavaScript object whose properties should be output
	 */

<span id='log-logger-method-error'>	/**
</span>	 * Writes a message to the log with level `error`
	 * @method error
	 * @inheritdoc #log
	 */

<span id='log-logger-method-info'>	/**
</span>	 * Writes a message to the log with level `info`.
	 * @method info
	 * @inheritdoc #log
	 */

<span id='log-logger-method-log'>	/**
</span>	 * Writes a message to the log with level `log`
	 * @method log
	 * @param {Object|String} payload Initial payload
	 * @param {Object...} [obj] Supplementary payloads
	 *
	 * - If `payload` is of type `Object` the string representations of each of these objects are appended together in the order listed and output.
	 * - If `payload` is of type `String` these are JavaScript objects with which to replace substitution strings within payload.
	 */

<span id='log-logger-method-time'>	/**
</span>	 * Starts a timer you can use to track how long an operation takes. You give each timer a unique name, and may have up to 10,000 timers running on a given page.
	 * When you call {@link #timeEnd} with the same name, the log will output the time, in milliseconds, that elapsed since the timer was started.
	 * @method time
	 * @param {String} timerName The name to give the new timer. This will identify the timer; use the same name when calling {@link #timeEnd} to stop the timer and get the time written to the log
	 */

<span id='log-logger-method-timeEnd'>	/**
</span>	 * Stops a timer that was previously started by calling {@link #time}.
	 * @method timeEnd
	 * @param {String} timerName The name of the timer to stop. Once stopped, the elapsed time is automatically written to the log
	 */

<span id='log-logger-method-trace'>	/**
</span>	 * Outputs a stack trace to the log.
	 * @method trace
	 */

<span id='log-logger-method-warn'>	/**
</span>	 * Writes a message to the log with level `warn`
	 * @method warn
	 * @inheritdoc #log
	 */

	return logger;
});</pre>
</body>
</html>
