<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='global-property-'>/**
</span> * @license MIT http://troopjs.mit-license.org/
 */
define([
	&quot;./config&quot;,
	&quot;troopjs-core/component/signal/start&quot;,
	&quot;require&quot;,
	&quot;when/when&quot;,
	&quot;jquery&quot;,
	&quot;mu-getargs/main&quot;,
	&quot;poly/array&quot;
], function (config, start, parentRequire, when, $, getargs) {
	&quot;use strict&quot;;

<span id='widget-weave'>	/**
</span>	 * @class widget.weave
	 * @mixin widget.config
	 * @mixin Function
	 * @static
	 */

	var UNDEFINED;
	var NULL = null;
	var ARRAY_PROTO = Array.prototype;
	var ARRAY_MAP = ARRAY_PROTO.map;
	var ARRAY_PUSH = ARRAY_PROTO.push;
	var DEFERRED = &quot;deferred&quot;;
	var MODULE = &quot;module&quot;;
	var LENGTH = &quot;length&quot;;
	var $WEFT = config.widget.$weft;
	var ATTR_WEAVE = config.widget.weave;
	var ATTR_WOVEN = config.widget.woven;
	var RE_SEPARATOR = /[\s,]+/;

<span id='global-method-S-weave'>	/**
</span>	 * Weaves `$element`
	 * @param {String} weave_attr
	 * @param {Array} constructor_args
	 * @return {Promise}
	 * @ignore
	 */
	function $weave(weave_attr, constructor_args) {
		// Let `$element` be `this`
		var $element = this;

<span id='widget-weave-method-S-map'>		/**
</span>		 * Maps `value` to `$data[value]`
		 * @param {*} value
		 * @return {*}
		 * @private
		 */
		var $map = function (value) {
			return $data.hasOwnProperty(value)
				? $data[value]
				: value;
		};

		// Get all data from `$element`
		var $data = $element.data();
		// Let `$weft` be `$data[$WEFT]` or `$data[$WEFT] = []`
		var $weft = $data.hasOwnProperty($WEFT)
			? $data[$WEFT]
			: $data[$WEFT] = [];
		// Scope `weave_re` locally since we use the `g` flag
		var weave_re = /[\s,]*(((?:\w+!)?([\w\/\.\-]+)(?:#[^(\s]+)?)(?:\((.*?)\))?)/g;
		// Let `weave_args` be `[]`
		var weave_args = [];
		var weave_arg;
		var args;
		var matches;

		// Iterate while `weave_re` matches
		// matches[1] : max widget name with args - &quot;mv!widget/name#1.x(1, 'string', false)&quot;
		// matches[2] : max widget name - &quot;mv!widget/name#1.x&quot;
		// matches[3] : min widget name - &quot;widget/name&quot;
		// matches[4] : widget arguments - &quot;1, 'string', false&quot;
		while ((matches = weave_re.exec(weave_attr)) !== NULL) {
			// Let `weave_arg` be [ $element, widget display name ].
			// Push `weave_arg` on `weave_args`
			ARRAY_PUSH.call(weave_args, weave_arg = [ $element, matches[3] ]);

			// Let `weave_arg[MODULE]` be `matches[2]`
			weave_arg[MODULE] = matches[2];
			// If there were additional arguments ...
			if ((args = matches[4]) !== UNDEFINED) {
				// .. parse them using `getargs`, `.map` the values with `$map` and push to `weave_arg`
				ARRAY_PUSH.apply(weave_arg, getargs.call(args).map($map));
			}

			// Let `weave_arg[DEFERRED]` be `when.defer()`
			// Push `weave_arg[DEFERRED].promise` on `$weft`
			ARRAY_PUSH.call($weft, (weave_arg[DEFERRED] = when.defer()).promise);

			// Push `constructor_args` on `weave_arg`
			ARRAY_PUSH.apply(weave_arg, constructor_args);
		}

		// Start async promise chain
		return when
			// Require, instantiate and start
			.map(weave_args, function (widget_args) {
				// Let `deferred` be `widget_args[DEFERRED]`
				var deferred = widget_args[DEFERRED];

				// Extract `resolve`, `reject` and `promise` from `deferred`
				var resolve = deferred.resolve;
				var reject = deferred.reject;

				// Require `weave_arg[MODULE]`
				parentRequire([ widget_args[MODULE] ], function (Widget) {
					var widget;
					var $deferred;

					// Create widget instance
					widget = Widget.apply(Widget, widget_args);

					// TroopJS &lt;= 1.x (detect presence of ComposeJS)
					if (widget.constructor._getBases) {
						// Let `$deferred` be `$.Deferred()`
						$deferred = $.Deferred();

						// Get trusted promise
						when($deferred)
							// Yield
							.yield(widget)
							// Link
							.then(resolve, reject);

						// Start widget
						widget.start($deferred);
					}
					// TroopJS &gt;= 2.x
					else {
						// Start widget
						start.call(widget)
							// Yield
							.yield(widget)
							// Link
							.then(resolve, reject);
					}
				}, reject);

				// Return `deferred.promise`
				return deferred.promise;
			})
			// Update `ATTR_WOVEN`
			.tap(function (widgets) {
				// Bail fast if no widgets were woven
				if (widgets[LENGTH] === 0) {
					return;
				}

				// Map `Widget[]` to `String[]`
				var woven = widgets.map(function (widget) {
					return widget.toString();
				});

				// Update `$element` attribute `ATTR_WOVEN`
				$element.attr(ATTR_WOVEN, function (index, attr) {
					// Split `attr` and concat with `woven`
					var values = (attr === UNDEFINED ? ARRAY_PROTO : attr.split(RE_SEPARATOR)).concat(woven);
					// If `values[LENGTH]` is not `0` ...
					return values[LENGTH] !== 0
						// ... return `values.join(&quot; &quot;)`
						? values.join(&quot; &quot;)
						// ... otherwise return `NULL` to remove the attribute
						: NULL;
				});
			});
	}

<span id='widget-weave-method-constructor'>	/**
</span>	 * Instantiate all {@link widget.component widgets}  specified in the `data-weave` attribute
	 * of this element, and to signal the widget for start with the arguments.
	 *
	 * The weaving will result in:
	 *
	 *  - Updates the `data-woven` attribute with the created widget instances names.
	 *  - The `$weft` data property will reference the widget instances.
	 *
	 * @localdoc
	 *
	 * It also lives as a jquery plugin as {@link $#method-weave}.
	 *
	 * **Note:** It's not commonly to use this method directly, use instead {@link $#method-weave jQuery.fn.weave}.
	 *
	 * 	// Create element for weaving
	 * 	var $el = $('&lt;div data-weave=&quot;my/widget(option)&quot;&gt;&lt;/div&gt;')
	 * 	// Populate `data`
	 * 	.data(&quot;option&quot;,{&quot;foo&quot;:&quot;bar&quot;})
	 * 	// Instantiate the widget defined in &quot;my/widget&quot; module, with one param read from the element's custom data.
	 * 	.weave();
	 *
	 * @method constructor
	 * @param {...*} [args] Arguments that will be passed to the {@link core.component.signal.start start} signal
	 * @return {Promise} Promise for the completion of weaving all widgets.
	 */
	return function weave() {
		// Let `constructor_args` be `arguments`
		var constructor_args = arguments;

		// Wait for map (sync) and weave (async)
		return when.all(ARRAY_MAP.call(this, function (element) {
			// Bless `$element` with `$`
			var $element = $(element);
			// Get ATTR_WEAVE attribute or default to `&quot;&quot;`
			var weave_attr = $element.attr(ATTR_WEAVE) || &quot;&quot;;
			// Make sure to remove ATTR_WEAVE asap in case someone else tries to `weave` again
			$element.removeAttr(ATTR_WEAVE);
			// Attempt weave
			return $weave.call($element, weave_attr, constructor_args);
		}));
	}
});
</pre>
</body>
</html>
