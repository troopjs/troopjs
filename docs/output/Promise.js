Ext.data.JsonP.Promise({"tagname":"class","name":"Promise","autodetected":{},"files":[{"filename":"Promise.js","href":"Promise.html#Promise"}],"members":[{"name":"constructor","tagname":"method","owner":"Promise","id":"method-constructor","meta":{}},{"name":"catch","tagname":"method","owner":"Promise","id":"method-catch","meta":{}},{"name":"then","tagname":"method","owner":"Promise","id":"method-then","meta":{}},{"name":"all","tagname":"method","owner":"Promise","id":"static-method-all","meta":{"static":true}},{"name":"race","tagname":"method","owner":"Promise","id":"static-method-race","meta":{"static":true}},{"name":"reject","tagname":"method","owner":"Promise","id":"static-method-reject","meta":{"static":true}},{"name":"resolve","tagname":"method","owner":"Promise","id":"static-method-resolve","meta":{"static":true}}],"alternateClassNames":[],"aliases":{},"id":"class-Promise","short_doc":"The Promise interface represents a proxy for a value not necessarily known when the promise is created. ...","classIcon":"icon-class","superclasses":[],"subclasses":[],"mixedInto":[],"implementedBy":[],"mixins":[],"implements":[],"parentMixins":[],"requires":[],"uses":[],"html":"<div><pre class=\"hierarchy\"><h4>Files</h4><div class='dependency'><a href='source/Promise.html#Promise' target='_blank'>Promise.js</a></div></pre><div class='doc-contents'><p>The <code>Promise</code> interface represents a proxy for a value not necessarily known when the promise is created.\nIt allows you to associate handlers to an asynchronous action's eventual success or failure.\nThis lets asynchronous methods return values like synchronous methods: instead of the final value,\nthe asynchronous method returns a <em>promise</em> of having a value at some point in the future.</p>\n\n<p>A pending promise can become either <em>fulfilled</em> with a value, or <em>rejected</em> with a reason.\nWhen either of these happens, the associated handlers queued up by a promise's <code>then</code> method are called.\n(If the promise has already been fulfilled or rejected when a corresponding handler is attached, the handler\nwill be called, so there is no race condition between an asynchronous operation completing and its handlers being attached.)</p>\n\n<p>As the <a href=\"#!/api/Promise-method-then\" rel=\"Promise-method-then\" class=\"docClass\">then</a> and <a href=\"#!/api/Promise-method-catch\" rel=\"Promise-method-catch\" class=\"docClass\">catch</a> methods return promises, they can be chainedâ€”an operation called <em>composition</em>.</p>\n\n<div class=\"notice\">\nDocumentation for this class comes from <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Promise\">MDN</a> and is available under <a href=\"http://creativecommons.org/licenses/by-sa/2.0/\">Creative Commons: Attribution-Sharealike license</a>.\n</div>\n\n</div><div class='members'><div class='members-section'><h3 class='members-title icon-method'>Methods</h3><div class='subsection'><div class='definedBy'>Defined By</div><h4 class='members-subtitle'>Instance methods</h3><div id='method-constructor' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Promise'>Promise</span><br/><a href='source/Promise.html#Promise-method-constructor' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Promise-method-constructor' class='name expandable'>Promise</a>( <span class='pre'>executor</span> ) : <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a><span class=\"signature\"></span></div><div class='description'><div class='short'>The Promise object is used for deferred and asynchronous computations. ...</div><div class='long'><p>The <code>Promise</code> object is used for deferred and asynchronous computations. A <code>Promise</code> is in one of the three states:</p>\n\n<ul>\n<li><code>pending</code>: initial state, not <code>fulfilled</code> or <code>rejected</code>.</li>\n<li><code>fulfilled</code>: successful operation</li>\n<li><code>rejected</code>: failed operation.</li>\n</ul>\n\n\n<p>Another term describing the state is <em>settled</em>: the Promise is either fulfilled or rejected, but not pending.</p>\n\n<pre><code>new Promise(executor);\nnew Promise(function(resolve, reject) { ... });\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>executor</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'><p>Function object with two arguments <code>resolve</code> and <code>reject</code>. The first argument fulfills the promise, the second argument rejects it. We can call these functions, once our operation is completed.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>resolve</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'><p>Function that resolves promise</p>\n</div></li><li><span class='pre'>reject</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'><p>Function that rejects promise</p>\n</div></li></ul></div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a></span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-catch' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Promise'>Promise</span><br/><a href='source/Promise.html#Promise-method-catch' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Promise-method-catch' class='name expandable'>catch</a>( <span class='pre'>onRejected</span> ) : <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a><span class=\"signature\"></span></div><div class='description'><div class='short'>The catch method returns a Promise and deals with rejected cases only. ...</div><div class='long'><p>The <code>catch</code> method returns a <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a> and deals with rejected cases only. It behaves the same as calling <a href=\"#!/api/Promise-method-then\" rel=\"Promise-method-then\" class=\"docClass\">then</a><code>(undefined, onRejected)</code>.</p>\n\n<pre><code>var p1 = new Promise(function(resolve, reject) {\n  resolve(\"Success\");\n});\n\np1.then(function(value) {\n  console.log(value); // \"Success!\"\n  throw \"oh, no!\";\n}).catch(function(e) {\n  console.log(e); // \"oh, no!\"\n});\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>onRejected</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'><p>A <code>Function</code> called when the <code>Promise</code> is rejected. This function has one argument, the rejection <code>reason</code>.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>reason</span> : Error|*<div class='sub-desc'><p>Reason why this <code>Promise</code> rejected.</p>\n</div></li></ul></div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a></span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-then' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Promise'>Promise</span><br/><a href='source/Promise.html#Promise-method-then' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Promise-method-then' class='name expandable'>then</a>( <span class='pre'>onFulfilled, onRejected</span> ) : <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a><span class=\"signature\"></span></div><div class='description'><div class='short'>The then method returns a Promise. ...</div><div class='long'><p>The <code>then</code> method returns a <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a>. It takes two arguments, both are callback functions for the success and failure cases of the Promise.</p>\n\n<pre><code>var p1 = new Promise(function(resolve, reject) {\n  resolve(\"Success!\");\n  // or\n  // reject (\"Error!\");\n});\n\np1.then(function(value) {\n  console.log(value); // Success!\n}, function(reason) {\n  console.log(reason); // Error!\n});\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>onFulfilled</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'><p>A <code>Function</code> called when the <code>Promise</code> is fulfilled. This function has one argument, the fulfillment <code>value</code>.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>value</span> : *<div class='sub-desc'><p>Argument to be resolved by this <code>Promise</code>. Can also be a <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a> or a <code>thenable</code> to resolve.</p>\n</div></li></ul></div></li><li><span class='pre'>onRejected</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'><p>A <code>Function</code> called when the <code>Promise</code> is rejected. This function has one argument, the rejection <code>reason</code>.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>reason</span> : Error|*<div class='sub-desc'><p>Reason why this <code>Promise</code> rejected.</p>\n</div></li></ul></div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a></span><div class='sub-desc'>\n</div></li></ul></div></div></div></div><div class='subsection'><div class='definedBy'>Defined By</div><h4 class='members-subtitle'>Static methods</h3><div id='static-method-all' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Promise'>Promise</span><br/><a href='source/Promise.html#Promise-static-method-all' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Promise-static-method-all' class='name expandable'>all</a>( <span class='pre'>iterable</span> ) : <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a><span class=\"signature\"><span class='static' >static</span></span></div><div class='description'><div class='short'>The Promise.all(iterable) method returns a promise that resolves when all of the promises in the iterable argument ha...</div><div class='long'><p>The <code><a href=\"#!/api/Promise-static-method-all\" rel=\"Promise-static-method-all\" class=\"docClass\">Promise.all</a>(iterable)</code> method returns a promise that resolves when all of the promises in the iterable argument have resolved.</p>\n\n<p>The result is passed as an array of values from all the promises. If something passed in the iterable array is not a promise,\nit's converted to one by <a href=\"#!/api/Promise-static-method-resolve\" rel=\"Promise-static-method-resolve\" class=\"docClass\">resolve</a>. If any of the passed in promises rejects, the <code>all</code> Promise immediately rejects with the value of the promise that rejected, discarding all the other promises whether or not they have resolved.</p>\n\n<pre><code>var p = new Promise(function(resolve, reject) { resolve(3); });\n<a href=\"#!/api/Promise-static-method-all\" rel=\"Promise-static-method-all\" class=\"docClass\">Promise.all</a>([true, p]).then(function(values) {\n  console.log(values); // [true, 3]\n});\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>iterable</span> : *<div class='sub-desc'><p>An iterable object, such as an <a href=\"#!/api/Array\" rel=\"Array\" class=\"docClass\">Array</a></p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a></span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='static-method-race' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Promise'>Promise</span><br/><a href='source/Promise.html#Promise-static-method-race' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Promise-static-method-race' class='name expandable'>race</a>( <span class='pre'>iterable</span> ) : <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a><span class=\"signature\"><span class='static' >static</span></span></div><div class='description'><div class='short'>The Promise.race(iterable) method returns a promise that resolves or rejects as soon as one of the promises in the it...</div><div class='long'><p>The <code><a href=\"#!/api/Promise-static-method-race\" rel=\"Promise-static-method-race\" class=\"docClass\">Promise.race</a>(iterable)</code> method returns a promise that resolves or rejects as soon as one of the promises in the iterable resolves or rejects, with the value or reason from that promise.</p>\n\n<p>The <code>race</code> function returns a <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a> that is settled the same way as the first passed promise to settle. It resolves or rejects, whichever happens first.</p>\n\n<pre><code>var p1 = new Promise(function(resolve, reject) {\n  setTimeout(resolve, 500, \"one\");\n});\nvar p2 = new Promise(function(resolve, reject) {\n  setTimeout(resolve, 100, \"two\");\n});\n\n<a href=\"#!/api/Promise-static-method-race\" rel=\"Promise-static-method-race\" class=\"docClass\">Promise.race</a>([p1, p2]).then(function(value) {\n  console.log(value); // \"two\"\n  // Both resolve, but p2 is faster\n});\n\nvar p3 = new Promise(function(resolve, reject) {\n  setTimeout(resolve, 100, \"three\");\n});\nvar p4 = new Promise(function(resolve, reject) {\n  setTimeout(reject, 500, \"four\");\n});\n\n<a href=\"#!/api/Promise-static-method-race\" rel=\"Promise-static-method-race\" class=\"docClass\">Promise.race</a>([p3, p4]).then(function(value) {\n  console.log(value); // \"three\"\n  // p3 is faster, so it resolves\n}, function(reason) {\n  // Not called\n});\n\nvar p5 = new Promise(function(resolve, reject) {\n  setTimeout(resolve, 500, \"five\");\n});\nvar p6 = new Promise(function(resolve, reject) {\n  setTimeout(reject, 100, \"six\");\n});\n\n<a href=\"#!/api/Promise-static-method-race\" rel=\"Promise-static-method-race\" class=\"docClass\">Promise.race</a>([p5, p6]).then(function(value) {\n  // Not called\n}, function(reason) {\n  console.log(reason); // \"six\"\n  // p6 is faster, so it rejects\n});\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>iterable</span> : *<div class='sub-desc'><p>An iterable object, such as an <a href=\"#!/api/Array\" rel=\"Array\" class=\"docClass\">Array</a></p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a></span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='static-method-reject' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Promise'>Promise</span><br/><a href='source/Promise.html#Promise-static-method-reject' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Promise-static-method-reject' class='name expandable'>reject</a>( <span class='pre'>reason</span> ) : <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a><span class=\"signature\"><span class='static' >static</span></span></div><div class='description'><div class='short'>The Promise.reject(reason) method returns a Promise object that is rejected with the given reason. ...</div><div class='long'><p>The <code><a href=\"#!/api/Promise-static-method-reject\" rel=\"Promise-static-method-reject\" class=\"docClass\">Promise.reject</a>(reason)</code> method returns a Promise object that is rejected with the given reason.</p>\n\n<p>The static <code><a href=\"#!/api/Promise-static-method-reject\" rel=\"Promise-static-method-reject\" class=\"docClass\">Promise.reject</a></code> function returns a <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a> that is rejected. For debugging purposes, it is useful to make <code>reason</code> an instanceof <code>Error</code>.</p>\n\n<pre><code><a href=\"#!/api/Promise-static-method-reject\" rel=\"Promise-static-method-reject\" class=\"docClass\">Promise.reject</a>(\"Testing static reject\").then(function(reason) {\n  // not called\n}, function(reason) {\n  console.log(reason); // \"Testing static reject\"\n});\n\n<a href=\"#!/api/Promise-static-method-reject\" rel=\"Promise-static-method-reject\" class=\"docClass\">Promise.reject</a>(new Error(\"fail\")).then(function(error) {\n  // not called\n}, function(error) {\n  console.log(error); // Stacktrace\n});\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>reason</span> : Error|*<div class='sub-desc'><p>Reason why this <code>Promise</code> rejected.</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a></span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='static-method-resolve' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Promise'>Promise</span><br/><a href='source/Promise.html#Promise-static-method-resolve' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Promise-static-method-resolve' class='name expandable'>resolve</a>( <span class='pre'>value</span> ) : <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a><span class=\"signature\"><span class='static' >static</span></span></div><div class='description'><div class='short'>The Promise.resolve(value) method returns a Promise object that is resolved with the given value. ...</div><div class='long'><p>The <code><a href=\"#!/api/Promise-static-method-resolve\" rel=\"Promise-static-method-resolve\" class=\"docClass\">Promise.resolve</a>(value)</code> method returns a <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a> object that is resolved with the given value. If the value is a thenable (i.e. has a <code>then</code> method), the returned promise will \"follow\" that thenable, adopting its eventual state; otherwise the returned promise will be fulfilled with the value.</p>\n\n<pre><code><a href=\"#!/api/Promise-static-method-resolve\" rel=\"Promise-static-method-resolve\" class=\"docClass\">Promise.resolve</a>(\"Success\").then(function(value) {\n  console.log(value); // \"Success\"\n}, function(value) {\n  // not called\n});\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>value</span> : *<div class='sub-desc'><p>Argument to be resolved by this <code>Promise</code>. Can also be a <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a> or a <code>thenable</code> to resolve.</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a></span><div class='sub-desc'>\n</div></li></ul></div></div></div></div></div></div></div>","meta":{}});